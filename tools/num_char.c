/* @(#)highwire/tools/num_char.c
 *
 * Inquires the number of available Unicode characters for each font.
 * Rainer Seitel, 2002-08-02
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef __PUREC__
#include <tos.h>
#endif

#ifdef LATTICE
#include <dos.h>
#include <mintbind.h>
#endif

#ifdef __GNUC__
#include <osbind.h>
#endif

#define E_OK 0
#define DOM_MINT 1
#define S_INQUIRE -1
#define S_GETCOOKIE 8

#include <gemx.h>


typedef short BOOL;
typedef short WORD;
typedef unsigned short UWORD;
#define FALSE 0
#define TRUE 1
#define ONLY_UNICODE

typedef struct {
	WORD handle;
	WORD dev_id;
	WORD wchar;
	WORD hchar;
	WORD wbox;
	WORD hbox;
	WORD xres;
	WORD yres;
	WORD noscale;
	WORD xpixel;
	WORD hpixel;
	WORD cheights;
	WORD linetypes;
	WORD linewidths;
	WORD markertypes;
	WORD markersizes;
	WORD faces;
	WORD patterns;
	WORD hatches;
	WORD colours;
	WORD ngdps;
	WORD cangdps[10];
	WORD gdpattr[10];
	WORD cancolour;
	WORD cantextrot;
	WORD canfillarea;
	WORD cancellarray;
	WORD palette;
	WORD locators;
	WORD valuators;
	WORD choicedevs;
	WORD stringdevs;
	WORD wstype;
	WORD minwchar;
	WORD minhchar;
	WORD maxwchar;
	WORD maxhchar;
	WORD minwline;
	WORD zero5;
	WORD maxwline;
	WORD zero7;
	WORD minwmark;
	WORD minhmark;
	WORD maxwmark;
	WORD maxhmark;
	WORD screentype;
	WORD bgcolors;
	WORD textfx;
	WORD canscale;
	WORD planes;
	WORD lut;
	WORD rops;
	WORD cancontourfill;
	WORD textrot;
	WORD writemodes;
	WORD inputmodes;
	WORD textalign;
	WORD inking;
	WORD rubberbanding;
	WORD maxvertices;
	WORD maxintin;
	WORD mousebuttons;
	WORD widestyles;
	WORD widemodes;
	WORD clipflag;  /* GEM 2, NVDI */
	WORD pixelm;  /* GEM 3 */
	WORD wpixelm;  /* GEM 3 */
	WORD hpixelm;  /* GEM 3 */
	WORD hpixelperinch;  /* GEM 3 */
	WORD vpixelperinch;  /* GEM 3 */
	WORD prnrot;  /* GEM 3 */
	void *quarter;  /* GEM 3 */
	WORD flags;  /* GEM 3, NVDI */
	WORD zero8;
	WORD flags2;  /* NVDI 5 */
	WORD zero9[14];
	WORD clipx;  /* undocumented! */
	WORD clipy;  /* undocumented! */
	WORD clipw;  /* undocumented! */
	WORD cliph;  /* undocumented! */
	WORD reserved[8];
} VDI_Workstation;

VDI_Workstation vdi_dev;


WORD V_Opnvwk(VDI_Workstation *dev)
{
	WORD i, in[11];

	in[0] = Getrez() + 2;
	dev->dev_id = in[0];
	for (i = 1; i < 10; in[i++] = 1)
		;
	in[10] = 2;
	i = graf_handle(&dev->wchar, &dev->hchar, &dev->wbox, &dev->hbox);
	v_opnvwk(in, &i, &dev->xres);
	dev->handle = i;

	if (i)
		vq_extnd(i, 1, &dev->screentype);

	return i;
}


/* getcookie() reads a 32-bit configuration cookie from the system cookie jar.
 * The pointer 'value' can be NULL.
 */
BOOL getcookie(long cookie, void *value)
{
	static BOOL use_ssystem = -1;
	long val = -1;
	typedef struct {
		long id;
		long val;
	} COOKJAR;
	COOKJAR	*cookiejar;
	WORD i;

	if (use_ssystem < 0)
		use_ssystem = Ssystem(S_INQUIRE, 0, 0) == E_OK;

	if (use_ssystem) {
		if (Ssystem(S_GETCOOKIE, cookie, (long)&val) == E_OK) {
			if (value)
				*(long *)value = val;
			return TRUE;
		}
	} else {
		cookiejar = (COOKJAR *)Setexc(0x5A0/4, (void (*)())-1);
		if (cookiejar) {
			for (i = 0; cookiejar[i].id; i++)
				if (cookiejar[i].id == cookie) {
					if (value)
						*(long *)value = cookiejar[i].val;
					return TRUE;
				}
		}
	}

	return FALSE;
}


int main(void)
{
	WORD tracks, pairs, dummy;
	long gdostype;
	NVDI_STRUC *nvdi = NULL;
	UWORD number_of_fonts, i, f, n, n_private, format, flags;
	char fontname[33];
	WCHAR wc;
	int type, mono, symbol;

	/* num_char needs a Speedo fonts GDOS, that is SpeedoGDOS or NVDI >= 3.
	 * Problem: If NVDI is in mode TOS bug compatibility, it returns -65536.
	 * In this case check if the cookie FSMC exists.
	 */
	gdostype = vq_vgdos();
	if ((gdostype != GDOS_FSM) && !(gdostype == -65536L && getcookie(0x46534D43L, NULL))) {
		fprintf(stderr, "num_char needs SpeedoGDOS or NVDI >= 3!");
		return EXIT_FAILURE;
	}

	if (V_Opnvwk(&vdi_dev) <= 0) {
		fprintf(stderr, "num_char can't open a VDI virtual workstation!\n");
		return EXIT_FAILURE;
	}

	printf("# Generated by num_char, Rainer Seitel, 2002-08-02\n#\n");

	if (!getcookie(0x4E564449L, &nvdi) || !nvdi || nvdi->nvdi_version < 0x400) {
		printf("Unicode TrueType fonts need NVDI >= 4.  Not found.\n#\n");
		vst_charmap(vdi_dev.handle, MAP_BITSTREAM);
	} else {
		vst_map_mode(vdi_dev.handle, MAP_UNICODE);
	}

	if (nvdi) {
		printf("# Using NVDI %X.%02X (%04X-%02X-%02X)\n#\n",
		       nvdi->nvdi_version >> 8, nvdi->nvdi_version & 0xFF,
		       (UWORD)nvdi->nvdi_datum, ((UWORD)(nvdi->nvdi_datum >> 16)) & 0xFF,
		       (UWORD)(nvdi->nvdi_datum >> 24) & 0xFF);
	}

	printf("# Lists the number of Unicode, additional private use characters,\n"
	       "# track kerning availability,\n"
	       "# the number of kerning pairs\n"
	       "#                                        B.. bitmap font\n"
	       "#                                        V.. vector font of unknown type\n"
	       "#                                        S.. Speedo font\n"
	       "#                                        T.. TrueType font\n"
	       "#                                        P.. PostScript Type 1 font\n"
	       "#                                        .m. monospaced\n"
	       "#                                        .p. proportional\n"
	       "#                                        ..s symbol font\n"
	       "# name                          ,    ID, ..., Unico, priva, track,pairs\n");

	(void)Pdomain(DOM_MINT);  /* we know about long file names */

	vst_scratch(vdi_dev.handle, SCRATCH_BOTH);
	number_of_fonts = vdi_dev.faces + vst_load_fonts(vdi_dev.handle, 0);

	for (i = 1; i <= number_of_fonts; i++) {
		/*f = vqt_name(vdi_dev.handle, i, fontname);*/
		f = vqt_ext_name(vdi_dev.handle, i, fontname, &format, &flags);
		vst_font(vdi_dev.handle, f);
		vst_kern(vdi_dev.handle, TRACK_NORMAL, PAIR_ON, &tracks, &pairs);

		/* These two flags are only valid for NVDI 3 compatible GDOS.  Otherwise
		 * they are reset by the default branch of the following switch.
		 */
		mono = (flags & 1)? 'm' : 'p';
		symbol = (flags & 16)? 's' : ' ';

		switch (format) {
		case 1:  /* bitmap font */
			type = 'B';
			break;
		case 2:  /* Speedo font */
			type = 'S';
			break;
		case 4:  /* TrueType font */
			type = 'T';
			break;
		case 8:  /* PostScript Type 1 font */
			type = 'P';
			break;
		default:  /* no NVDI 3 compatible GDOS (control[4] < 35) */
			if (fontname[32])
				type = 'V';
			else
				type = 'B';
			mono = ' ';
			symbol = ' ';
			break;
		}

		if (type != 'B' && nvdi && nvdi->nvdi_version >= 0x400)
			for (wc = 0x0020, n = n_private = 0; wc <= 0xFFFC; wc++) {
				if (vqt_char_index(vdi_dev.handle, wc, MAP_UNICODE, MAP_BITSTREAM) != 0xFFFFU)
					if (wc >= 0xE000U && wc <= 0xF8FFU)
						n_private++;
					else
						n++;
			}
		else
			for (wc = 0, n = n_private = 0; wc <= 563; wc++) {
				if (vqt_width(vdi_dev.handle, wc, &dummy, &dummy, &dummy) != -1)
					n++;
			}

		printf("%-32.32s, %5u, %c%c%c, %5u, %5u, %u, %5u\n",
		       fontname, f, type, mono, symbol, n, n_private, tracks, pairs);
	}

	return EXIT_SUCCESS;
}  /* main() */
